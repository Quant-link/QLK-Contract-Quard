"""
Comprehensive Vulnerability Detector for Multi-Language Smart Contracts.

This module provides advanced vulnerability detection capabilities that work
across Rust, Solidity, and Go smart contracts using the unified IR.
"""

import logging
import re
from typing import List, Dict, Set, Any, Optional, Pattern
from dataclasses import dataclass
from enum import Enum

from ..core.findings import Finding, Severity, SourceLocation
from ..ir.nodes import (
    IRModule, IRFunction, IRContract, IRStatement, IRExpression,
    StatementType, ExpressionType, Visibility, IRFunctionCall, IRBinaryOperation
)


class VulnerabilityCategory(Enum):
    """Categories of vulnerabilities."""
    REENTRANCY = "reentrancy"
    ACCESS_CONTROL = "access_control"
    INTEGER_OVERFLOW = "integer_overflow"
    ORACLE_MANIPULATION = "oracle_manipulation"
    DENIAL_OF_SERVICE = "denial_of_service"
    FRONTRUNNING = "frontrunning"
    RACE_CONDITION = "race_condition"
    MEMORY_SAFETY = "memory_safety"
    LOGIC_ERROR = "logic_error"
    CRYPTOGRAPHIC = "cryptographic"


@dataclass
class VulnerabilityPattern:
    """Represents a vulnerability detection pattern."""
    name: str
    category: VulnerabilityCategory
    description: str
    severity: Severity
    languages: Set[str]  # Languages this pattern applies to
    pattern_type: str  # 'ast', 'regex', 'semantic'
    detection_logic: Any  # Function or regex pattern


class VulnerabilityDetector:
    """
    Advanced vulnerability detector for multi-language smart contracts.
    
    This detector uses pattern matching, semantic analysis, and heuristics
    to identify security vulnerabilities across different languages.
    """
    
    def __init__(self):
        self.logger = logging.getLogger("contractquard.analysis.vulnerability_detector")
        self.patterns = self._initialize_patterns()
        self.language_specific_detectors = {
            'solidity': self._detect_solidity_vulnerabilities,
            'rust': self._detect_rust_vulnerabilities,
            'go': self._detect_go_vulnerabilities
        }
    
    def analyze_module(self, module: IRModule) -> List[Finding]:
        """
        Analyze a module for vulnerabilities.
        
        Args:
            module: IR module to analyze
            
        Returns:
            List of vulnerability findings
        """
        self.logger.debug(f"Starting vulnerability detection for module: {module.name}")
        
        findings = []
        
        # Detect language from file extension
        language = self._detect_language(module.name)
        
        # Run universal vulnerability detection
        universal_findings = self._detect_universal_vulnerabilities(module)
        findings.extend(universal_findings)
        
        # Run language-specific detection
        if language in self.language_specific_detectors:
            language_findings = self.language_specific_detectors[language](module)
            findings.extend(language_findings)
        
        # Run cross-contract analysis
        cross_contract_findings = self._detect_cross_contract_vulnerabilities(module)
        findings.extend(cross_contract_findings)
        
        self.logger.info(f"Vulnerability detection found {len(findings)} issues")
        return findings
    
    def _initialize_patterns(self) -> List[VulnerabilityPattern]:
        """Initialize vulnerability detection patterns."""
        patterns = []
        
        # Reentrancy patterns
        patterns.append(VulnerabilityPattern(
            name="external_call_before_state_change",
            category=VulnerabilityCategory.REENTRANCY,
            description="External call made before state changes",
            severity=Severity.HIGH,
            languages={'solidity', 'rust', 'go'},
            pattern_type='semantic',
            detection_logic=self._detect_reentrancy_pattern
        ))
        
        # Access control patterns
        patterns.append(VulnerabilityPattern(
            name="missing_access_control",
            category=VulnerabilityCategory.ACCESS_CONTROL,
            description="Public function without access control",
            severity=Severity.MEDIUM,
            languages={'solidity', 'rust', 'go'},
            pattern_type='semantic',
            detection_logic=self._detect_missing_access_control
        ))
        
        # Integer overflow patterns
        patterns.append(VulnerabilityPattern(
            name="unchecked_arithmetic",
            category=VulnerabilityCategory.INTEGER_OVERFLOW,
            description="Arithmetic operations without overflow checks",
            severity=Severity.HIGH,
            languages={'solidity', 'go'},
            pattern_type='semantic',
            detection_logic=self._detect_integer_overflow
        ))
        
        # Oracle manipulation patterns
        patterns.append(VulnerabilityPattern(
            name="single_oracle_dependency",
            category=VulnerabilityCategory.ORACLE_MANIPULATION,
            description="Dependency on single oracle source",
            severity=Severity.MEDIUM,
            languages={'solidity', 'rust', 'go'},
            pattern_type='semantic',
            detection_logic=self._detect_oracle_manipulation
        ))
        
        # Denial of service patterns
        patterns.append(VulnerabilityPattern(
            name="unbounded_loop",
            category=VulnerabilityCategory.DENIAL_OF_SERVICE,
            description="Loop with unbounded iterations",
            severity=Severity.MEDIUM,
            languages={'solidity', 'rust', 'go'},
            pattern_type='semantic',
            detection_logic=self._detect_unbounded_loops
        ))
        
        return patterns
    
    def _detect_universal_vulnerabilities(self, module: IRModule) -> List[Finding]:
        """Detect vulnerabilities that apply to all languages."""
        findings = []
        
        for contract in module.contracts:
            for function in contract.functions:
                # Check each pattern
                for pattern in self.patterns:
                    if self._pattern_applies_to_function(pattern, function, module):
                        pattern_findings = pattern.detection_logic(function, contract, module)
                        findings.extend(pattern_findings)
        
        # Check module-level functions
        for function in module.functions:
            for pattern in self.patterns:
                if self._pattern_applies_to_function(pattern, function, module):
                    pattern_findings = pattern.detection_logic(function, None, module)
                    findings.extend(pattern_findings)
        
        return findings
    
    def _detect_solidity_vulnerabilities(self, module: IRModule) -> List[Finding]:
        """Detect Solidity-specific vulnerabilities."""
        findings = []
        
        for contract in module.contracts:
            # Check for delegatecall vulnerabilities
            delegatecall_findings = self._detect_delegatecall_vulnerabilities(contract)
            findings.extend(delegatecall_findings)
            
            # Check for storage collision
            storage_findings = self._detect_storage_collision(contract)
            findings.extend(storage_findings)
            
            # Check for gas limit issues
            gas_findings = self._detect_gas_limit_issues(contract)
            findings.extend(gas_findings)
            
            # Check for timestamp dependence
            timestamp_findings = self._detect_timestamp_dependence(contract)
            findings.extend(timestamp_findings)
        
        return findings
    
    def _detect_rust_vulnerabilities(self, module: IRModule) -> List[Finding]:
        """Detect Rust-specific vulnerabilities."""
        findings = []
        
        for contract in module.contracts:
            # Check for unsafe block issues
            unsafe_findings = self._detect_unsafe_block_issues(contract)
            findings.extend(unsafe_findings)
            
            # Check for panic-induced DoS
            panic_findings = self._detect_panic_dos(contract)
            findings.extend(panic_findings)
            
            # Check for memory safety issues
            memory_findings = self._detect_memory_safety_issues(contract)
            findings.extend(memory_findings)
        
        return findings
    
    def _detect_go_vulnerabilities(self, module: IRModule) -> List[Finding]:
        """Detect Go-specific vulnerabilities."""
        findings = []
        
        for contract in module.contracts:
            # Check for goroutine leaks
            goroutine_findings = self._detect_goroutine_leaks(contract)
            findings.extend(goroutine_findings)
            
            # Check for race conditions
            race_findings = self._detect_race_conditions(contract)
            findings.extend(race_findings)
            
            # Check for channel deadlocks
            deadlock_findings = self._detect_channel_deadlocks(contract)
            findings.extend(deadlock_findings)
        
        return findings
    
    def _detect_cross_contract_vulnerabilities(self, module: IRModule) -> List[Finding]:
        """Detect vulnerabilities that span multiple contracts."""
        findings = []
        
        if len(module.contracts) > 1:
            # Check for interface inconsistencies
            interface_findings = self._detect_interface_inconsistencies(module.contracts)
            findings.extend(interface_findings)
            
            # Check for circular dependencies
            circular_findings = self._detect_circular_dependencies(module.contracts)
            findings.extend(circular_findings)
        
        return findings
    
    # Pattern detection methods
    
    def _detect_reentrancy_pattern(self, function: IRFunction, 
                                  contract: Optional[IRContract], 
                                  module: IRModule) -> List[Finding]:
        """Detect reentrancy vulnerability patterns."""
        findings = []
        
        # Look for external calls followed by state changes
        external_calls = []
        state_changes = []
        
        for i, stmt in enumerate(function.body):
            if self._is_external_call(stmt):
                external_calls.append(i)
            elif self._is_state_change(stmt):
                state_changes.append(i)
        
        # Check if state changes occur after external calls
        for call_idx in external_calls:
            for state_idx in state_changes:
                if state_idx > call_idx:
                    findings.append(Finding(
                        finding_id=f"reentrancy_{function.name}_{call_idx}_{state_idx}",
                        title="Potential Reentrancy Vulnerability",
                        description=f"Function {function.name} makes external call before state change",
                        severity=Severity.HIGH,
                        location=function.source_location,
                        vulnerability_type="reentrancy",
                        detector_name="vulnerability_detector"
                    ))
                    break
        
        return findings
    
    def _detect_missing_access_control(self, function: IRFunction, 
                                     contract: Optional[IRContract], 
                                     module: IRModule) -> List[Finding]:
        """Detect missing access control in public functions."""
        findings = []
        
        if (function.visibility == Visibility.PUBLIC and 
            not function.modifiers and 
            not function.is_view and 
            not function.is_pure):
            
            findings.append(Finding(
                finding_id=f"missing_access_control_{function.name}",
                title="Missing Access Control",
                description=f"Public function {function.name} lacks access control modifiers",
                severity=Severity.MEDIUM,
                location=function.source_location,
                vulnerability_type="access_control",
                detector_name="vulnerability_detector"
            ))
        
        return findings
    
    def _detect_integer_overflow(self, function: IRFunction, 
                               contract: Optional[IRContract], 
                               module: IRModule) -> List[Finding]:
        """Detect potential integer overflow vulnerabilities."""
        findings = []
        
        # Look for arithmetic operations without checks
        for stmt in function.body:
            if self._contains_arithmetic_operation(stmt):
                # Check if there are overflow checks nearby
                if not self._has_overflow_checks(function, stmt):
                    findings.append(Finding(
                        finding_id=f"integer_overflow_{function.name}_{hash(str(stmt))}",
                        title="Potential Integer Overflow",
                        description=f"Arithmetic operation in {function.name} may overflow",
                        severity=Severity.HIGH,
                        location=function.source_location,
                        vulnerability_type="integer_overflow",
                        detector_name="vulnerability_detector"
                    ))
        
        return findings
    
    def _detect_oracle_manipulation(self, function: IRFunction, 
                                  contract: Optional[IRContract], 
                                  module: IRModule) -> List[Finding]:
        """Detect oracle manipulation vulnerabilities."""
        findings = []
        
        # Look for single oracle dependencies
        oracle_calls = self._find_oracle_calls(function)
        
        if len(oracle_calls) == 1:
            findings.append(Finding(
                finding_id=f"single_oracle_{function.name}",
                title="Single Oracle Dependency",
                description=f"Function {function.name} depends on single oracle source",
                severity=Severity.MEDIUM,
                location=function.source_location,
                vulnerability_type="oracle_manipulation",
                detector_name="vulnerability_detector"
            ))
        
        return findings
    
    def _detect_unbounded_loops(self, function: IRFunction, 
                              contract: Optional[IRContract], 
                              module: IRModule) -> List[Finding]:
        """Detect unbounded loops that could cause DoS."""
        findings = []
        
        # Look for loops without clear bounds
        for stmt in function.body:
            if stmt.statement_type in [StatementType.WHILE, StatementType.FOR]:
                if not self._has_loop_bounds(stmt):
                    findings.append(Finding(
                        finding_id=f"unbounded_loop_{function.name}_{hash(str(stmt))}",
                        title="Unbounded Loop",
                        description=f"Loop in {function.name} may run indefinitely",
                        severity=Severity.MEDIUM,
                        location=function.source_location,
                        vulnerability_type="denial_of_service",
                        detector_name="vulnerability_detector"
                    ))
        
        return findings
    
    # Helper methods
    
    def _detect_language(self, file_path: str) -> str:
        """Detect language from file path."""
        if file_path.endswith('.sol'):
            return 'solidity'
        elif file_path.endswith('.rs'):
            return 'rust'
        elif file_path.endswith('.go'):
            return 'go'
        return 'unknown'
    
    def _pattern_applies_to_function(self, pattern: VulnerabilityPattern, 
                                   function: IRFunction, module: IRModule) -> bool:
        """Check if a pattern applies to a function."""
        language = self._detect_language(module.name)
        return language in pattern.languages
    
    def _is_external_call(self, stmt: IRStatement) -> bool:
        """Check if statement contains an external call."""
        # This would analyze the statement to detect external calls
        return False  # Simplified
    
    def _is_state_change(self, stmt: IRStatement) -> bool:
        """Check if statement changes contract state."""
        # This would analyze the statement to detect state changes
        return False  # Simplified
    
    def _contains_arithmetic_operation(self, stmt: IRStatement) -> bool:
        """Check if statement contains arithmetic operations."""
        # This would analyze the statement for arithmetic operations
        return False  # Simplified
    
    def _has_overflow_checks(self, function: IRFunction, stmt: IRStatement) -> bool:
        """Check if there are overflow checks for arithmetic operations."""
        # This would look for SafeMath usage or explicit checks
        return False  # Simplified
    
    def _find_oracle_calls(self, function: IRFunction) -> List[IRStatement]:
        """Find oracle calls in function."""
        # This would identify calls to oracle contracts
        return []  # Simplified
    
    def _has_loop_bounds(self, stmt: IRStatement) -> bool:
        """Check if loop has clear bounds."""
        # This would analyze loop conditions for bounds
        return True  # Simplified
    
    # Language-specific detection methods (simplified implementations)
    
    def _detect_delegatecall_vulnerabilities(self, contract: IRContract) -> List[Finding]:
        """Detect delegatecall vulnerabilities in Solidity."""
        return []
    
    def _detect_storage_collision(self, contract: IRContract) -> List[Finding]:
        """Detect storage collision vulnerabilities."""
        return []
    
    def _detect_gas_limit_issues(self, contract: IRContract) -> List[Finding]:
        """Detect gas limit related issues."""
        return []
    
    def _detect_timestamp_dependence(self, contract: IRContract) -> List[Finding]:
        """Detect timestamp dependence vulnerabilities."""
        return []
    
    def _detect_unsafe_block_issues(self, contract: IRContract) -> List[Finding]:
        """Detect unsafe block issues in Rust."""
        return []
    
    def _detect_panic_dos(self, contract: IRContract) -> List[Finding]:
        """Detect panic-induced DoS in Rust."""
        return []
    
    def _detect_memory_safety_issues(self, contract: IRContract) -> List[Finding]:
        """Detect memory safety issues in Rust."""
        return []
    
    def _detect_goroutine_leaks(self, contract: IRContract) -> List[Finding]:
        """Detect goroutine leaks in Go."""
        return []
    
    def _detect_race_conditions(self, contract: IRContract) -> List[Finding]:
        """Detect race conditions in Go."""
        return []
    
    def _detect_channel_deadlocks(self, contract: IRContract) -> List[Finding]:
        """Detect channel deadlocks in Go."""
        return []
    
    def _detect_interface_inconsistencies(self, contracts: List[IRContract]) -> List[Finding]:
        """Detect interface inconsistencies between contracts."""
        return []
    
    def _detect_circular_dependencies(self, contracts: List[IRContract]) -> List[Finding]:
        """Detect circular dependencies between contracts."""
        return []
